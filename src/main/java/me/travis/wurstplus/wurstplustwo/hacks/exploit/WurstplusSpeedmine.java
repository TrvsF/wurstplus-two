package me.travis.wurstplus.wurstplustwo.hacks.exploit;

import me.travis.wurstplus.wurstplustwo.event.events.WurstplusEventBlock;
import me.travis.wurstplus.wurstplustwo.event.events.WurstplusEventPacket;
import me.travis.wurstplus.wurstplustwo.guiscreen.settings.WurstplusSetting;
import me.travis.wurstplus.wurstplustwo.hacks.WurstplusCategory;
import me.travis.wurstplus.wurstplustwo.hacks.WurstplusHack;
import me.travis.wurstplus.wurstplustwo.util.WurstplusTimer;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketAnimation;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;

public class WurstplusSpeedmine extends WurstplusHack {
    
    public WurstplusSpeedmine() {
        super(WurstplusCategory.WURSTPLUS_EXPLOIT);

        this.name        = "Speed Mine";
        this.tag         = "SpeedMine";
        this.description = "mine faster";
    }

    WurstplusSetting mode = create("Mode", "SpeedmineMode", "Normal", combobox("Normal", "Packet", "Damage", "Instant"));
    WurstplusSetting damage = create("Damage Ammount", "SpeedmineDamagaeAmmount", 0.7, 0, 1);
    WurstplusSetting reset = create("Reset", "SpeedmineReset", true);
    WurstplusSetting no_break_anim = create("No Break Anim", "SpeedMineBreakAnim", false);
    WurstplusSetting no_delay = create("No Delay", "SpeedmineNoDelay", false);
    WurstplusSetting no_swing = create("No Swing", "SpeedmineNoSwing", false);
    WurstplusSetting allow = create("MultiTask", "SpeedmineMultiTask", false);
    WurstplusSetting double_break = create("Double Break", "SpeedmineDoubleBreak", false);

    private final WurstplusTimer timer = new WurstplusTimer();

    private IBlockState current_block_state = null;

    private BlockPos current_pos = null;
    private BlockPos last_pos = null;

    private EnumFacing last_facing = null;

    private boolean is_mining = false;



    @Override
    public void update() {
        if (current_pos != null &&
                (!mc.world.getBlockState(current_pos).equals(current_block_state) || mc.world.getBlockState(current_pos).getBlock() == Blocks.AIR)) {
                current_pos = null;
                current_block_state = null;
        }

        if (no_delay.get_value(true)) {
            mc.playerController.blockHitDelay = 0;
        }

        if (is_mining && last_pos != null && last_facing != null && no_break_anim.get_value(true)) {
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, last_pos, last_facing));
        }

        if (reset.get_value(true) && mc.gameSettings.keyBindUseItem.isKeyDown() && !allow.get_value(true)) {
            mc.playerController.isHittingBlock = false;
        }
    }

    @EventHandler
    private Listener<WurstplusEventPacket.SendPacket> send_listener = new Listener<>(event -> {
        if (no_swing.get_value(true) && event.get_packet() instanceof CPacketAnimation) {
            event.cancel();
        }

        if (no_break_anim.get_value(true) && event.get_packet() instanceof CPacketPlayerDigging) {
            final CPacketPlayerDigging p = (CPacketPlayerDigging) event.get_packet();
            try {
                for (final Entity entity : mc.world.getEntitiesWithinAABBExcludingEntity(null, new AxisAlignedBB(p.getPosition()))) {
                    if (entity instanceof EntityEnderCrystal) {
                        show_anim();
                        return;
                    }
                }
            } catch (Exception ignored){}

            if (p.getAction().equals(CPacketPlayerDigging.Action.START_DESTROY_BLOCK)) {
                show_anim(true, p.getPosition(), p.getFacing());
            }

            if (p.getAction().equals(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK)) {
                show_anim();
            }
        }
    });

    @EventHandler
    private Listener<WurstplusEventBlock> block_event = new Listener<>(event -> {
        if (event.get_stage() == 3 && reset.get_value(true) && mc.playerController.curBlockDamageMP > 0.1f) {
            mc.playerController.isHittingBlock = true;
        }
        if (event.get_stage() == 4 && !mode.in("Normal")) {
            if (canBreak(event.pos)) {
                if (reset.get_value(true)) {
                    mc.playerController.isHittingBlock = false;
                }

                if (mode.in("Packet")) {
                    if (current_pos == null) {
                        current_pos = event.pos;
                        current_block_state = mc.world.getBlockState(current_pos);
                        timer.reset();
                    }
                    mc.player.swingArm(EnumHand.MAIN_HAND);
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));
                    event.cancel();
                }

                if (mode.in("Damage")) {
                    if (mc.playerController.curBlockDamageMP >= damage.get_value(1)) {
                        mc.playerController.curBlockDamageMP = 1.0f;
                    }
                }

                if (mode.in("Instant")) {
                    mc.player.swingArm(EnumHand.MAIN_HAND);
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));
                    mc.playerController.onPlayerDestroyBlock(event.pos);
                    mc.world.setBlockToAir(event.pos);
                }

            }

            if (double_break.get_value(true)) {
                final BlockPos above = event.pos.up();
                if (canBreak(above) && mc.player.getDistance(above.getX(), above.getY(), above.getZ()) <= 5.0) {
                    mc.player.swingArm(EnumHand.MAIN_HAND);
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, above, event.facing));
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, above, event.facing));
                    mc.playerController.onPlayerDestroyBlock(above);
                    mc.world.setBlockToAir(above);
                }
            }

        }
    });

    public void show_anim(final boolean is_mining, final BlockPos last_pos, final EnumFacing last_facing) {
        this.is_mining = is_mining;
        this.last_pos = last_pos;
        this.last_facing = last_facing;
    }

    public void show_anim() {
        this.show_anim(false, null, null);
    }

    @Override
    public String array_detail() {
        return mode.get_current_value();
    }

    public static boolean canBreak(final BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, mc.world, pos) != -1.0f;
    }

}